;; factorial pre-read
;; linear-recursive process

(define (factorial n)
	(if (= n 1)
		1
		(* n (factorial (- n 1)))))


;;Counter method
;; linear iterative process 

(define (fact n)
	(define (iter product counter)
		(if(> counter n)
			product
			(iter (* counter product) (+ counter 1))
		)	
	)	
	(iter 1 1))

(fact 5)


;; both of the above procedures can be described as 
;; "recursive procedures" since each calls itself, but only the top evaluates
;; as a recursive process. 

;; that is the bottom procedure simply calls itself with new variables,
;; durring this process only 3 values are kept track off, and memory 
;; usage does not grow. this is true with all lisps implimentations
;; and this property is know as tail-recursive. looping constructs in 
;; tail-recursive implementations can be expressed with ordinary 
;; procedure calls. This means that special iteration constructs
;; are only useful as sytactic sugur in tail recursive intrepreters.  

;; the process of the top procedure requires the interpreter to keep
;; track of more and more values as the process takes place. Memory 
;; usage grows -- this is a recursive process.

;; substitution models
;; factorial - recursive process 
(factorial 6) 
(* 6(factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factiorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720

;; fact - iterative process
(fact 6)
(iter 1 1 6)
(iter 1 2 6)
(iter 2 3 6)
(iter 6 4 6)
(iter 24 5 6)
(iter 120 6 6)
(iter 720 7 6)
720

;; as clearly shown iterative and recursive processes
;; can be described by the "shape" generated by their
;; respective substitution models

